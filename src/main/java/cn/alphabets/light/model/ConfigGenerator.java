package cn.alphabets.light.model;

import cn.alphabets.light.Constant;
import cn.alphabets.light.db.mongo.Model;
import com.squareup.javapoet.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.text.WordUtils;
import org.bson.Document;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.*;

/**
 * Generator
 * Created by lilin on 2016/11/8.
 */
public class ConfigGenerator {

    private String packageName;
    private TypeSpec.Builder builder;

    public ConfigGenerator(String packageName, String className) {
        this.packageName = packageName;
        builder = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("Generated by the Light platform. Do not manually modify the code.\n");
    }

    public void generate(String domain) {

        Model model = new Model(domain, Constant.SYSTEM_DB_PREFIX, Constant.SYSTEM_DB_CONFIG);
        List<Document> configs = model.document(new Document(), Arrays.asList("type", "key", "value", "valueType"));
        Map<String, TypeSpec.Builder> classes = new HashMap<>();

        configs.forEach((config) -> {

            String type = (String) config.get("type");
            String keys = (String) config.get("key");
            Object value = config.get("value");
            String valueType = (String) config.get("valueType");

            if (!classes.containsKey(type)) {
                classes.put(type, this.createSubClass(type));
                this.builder.addField(this.createField(type));
            }

            TypeSpec.Builder current = classes.get(type);
            String[] keyList = keys.split("\\.");
            for (int i = 0; i < keyList.length; i++) {
                String key = keyList[i];
                boolean isLast = (i == keyList.length - 1);

                if (isLast) {
                    current.addMethod(this.createGetter(key, ModelGenerator.regular(valueType), value));
                    break;
                }

                if (!classes.containsKey(key)) {
                    classes.put(key, this.createSubClass(key));
                    current.addField(this.createField(key));
                }

                current = classes.get(key);
            }
        });

        classes.entrySet().forEach((x) -> {
            this.builder.addType(x.getValue().build());
        });
    }

    private MethodSpec createGetter(String name, Type type, Object value) {

        TypeName returnType = TypeName.get(type);
        String format = "return $L";

        if (type == String.class) {
            format = "return $S";
        }

        if (type == Long.class) {
            format = "return $LL";
        }

        if (type == List.class) {

            ClassName list = ClassName.get("java.util", "List");
            ClassName string = ClassName.get("java.lang", "String");
            returnType = ParameterizedTypeName.get(list, string);

            if (((List) value).size() < 1) {
                value = "new java.util.ArrayList<>()";
            } else {
                String repeating = StringUtils.repeat("\"%s\",\n", ((List) value).size());
                repeating = String.format("java.util.Arrays.asList(%s)", repeating.substring(0, repeating.length() - 2));
                value = String.format(repeating, ((List) value).toArray());
            }
        }

        return MethodSpec.methodBuilder("get" + WordUtils.capitalize(name))
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .returns(returnType)
                .addStatement(format, value)
                .build();
    }

    private FieldSpec createField(String name) {

        ClassName type = ClassName.get("", WordUtils.capitalize(name));

        return FieldSpec.builder(type, name)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .initializer("new $T()", type)
                .build();
    }

    private TypeSpec.Builder createSubClass(String name) {
        return TypeSpec.classBuilder(WordUtils.capitalize(name))
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
    }

    public void write() throws IOException {
        JavaFile javaFile = JavaFile.builder(this.packageName, builder.build()).build();
        javaFile.writeTo(System.out);
    }
}
